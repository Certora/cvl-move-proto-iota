#[allow(unused_function)]
module certora::iota_address_summaries;

use cvlm::manifest::summary;
use cvlm::conversions::u256_to_address;

fun cvlm_manifest() {
    summary(b"from_u256", @iota, b"address", b"from_u256");
    summary(b"from_bytes", @iota, b"address", b"from_bytes");
}

// #[summary(iota::address::from_u256)]
fun from_u256(n: u256): address { 
    u256_to_address(n) 
}

// #[summary(iota::address::from_bytes)]
fun from_bytes(bytes: vector<u8>): address {
    assert!(bytes.length() == 32);
    let mut n = 0u256;

    // It would be nice to use a loop here; we should revisit after the prover is better able to unroll Move loops.
    n = n + (bytes[00] as u256) * 0x0100000000000000000000000000000000000000000000000000000000000000u256;
    n = n + (bytes[01] as u256) * 0x0001000000000000000000000000000000000000000000000000000000000000u256;
    n = n + (bytes[02] as u256) * 0x0000010000000000000000000000000000000000000000000000000000000000u256;
    n = n + (bytes[03] as u256) * 0x0000000100000000000000000000000000000000000000000000000000000000u256;
    n = n + (bytes[04] as u256) * 0x0000000001000000000000000000000000000000000000000000000000000000u256;
    n = n + (bytes[05] as u256) * 0x0000000000010000000000000000000000000000000000000000000000000000u256;
    n = n + (bytes[06] as u256) * 0x0000000000000100000000000000000000000000000000000000000000000000u256;
    n = n + (bytes[07] as u256) * 0x0000000000000001000000000000000000000000000000000000000000000000u256;
    n = n + (bytes[08] as u256) * 0x0000000000000000010000000000000000000000000000000000000000000000u256;
    n = n + (bytes[09] as u256) * 0x0000000000000000000100000000000000000000000000000000000000000000u256;
    n = n + (bytes[10] as u256) * 0x0000000000000000000001000000000000000000000000000000000000000000u256;
    n = n + (bytes[11] as u256) * 0x0000000000000000000000010000000000000000000000000000000000000000u256;
    n = n + (bytes[12] as u256) * 0x0000000000000000000000000100000000000000000000000000000000000000u256;
    n = n + (bytes[13] as u256) * 0x0000000000000000000000000001000000000000000000000000000000000000u256;
    n = n + (bytes[14] as u256) * 0x0000000000000000000000000000010000000000000000000000000000000000u256;
    n = n + (bytes[15] as u256) * 0x0000000000000000000000000000000100000000000000000000000000000000u256;
    n = n + (bytes[16] as u256) * 0x0000000000000000000000000000000001000000000000000000000000000000u256;
    n = n + (bytes[17] as u256) * 0x0000000000000000000000000000000000010000000000000000000000000000u256;
    n = n + (bytes[18] as u256) * 0x0000000000000000000000000000000000000100000000000000000000000000u256;
    n = n + (bytes[19] as u256) * 0x0000000000000000000000000000000000000001000000000000000000000000u256;
    n = n + (bytes[20] as u256) * 0x0000000000000000000000000000000000000000010000000000000000000000u256;
    n = n + (bytes[21] as u256) * 0x0000000000000000000000000000000000000000000100000000000000000000u256;
    n = n + (bytes[22] as u256) * 0x0000000000000000000000000000000000000000000001000000000000000000u256;
    n = n + (bytes[23] as u256) * 0x0000000000000000000000000000000000000000000000010000000000000000u256;
    n = n + (bytes[24] as u256) * 0x0000000000000000000000000000000000000000000000000100000000000000u256;
    n = n + (bytes[25] as u256) * 0x0000000000000000000000000000000000000000000000000001000000000000u256;
    n = n + (bytes[26] as u256) * 0x0000000000000000000000000000000000000000000000000000010000000000u256;
    n = n + (bytes[27] as u256) * 0x0000000000000000000000000000000000000000000000000000000100000000u256;
    n = n + (bytes[28] as u256) * 0x0000000000000000000000000000000000000000000000000000000001000000u256;
    n = n + (bytes[29] as u256) * 0x0000000000000000000000000000000000000000000000000000000000010000u256;
    n = n + (bytes[30] as u256) * 0x0000000000000000000000000000000000000000000000000000000000000100u256;
    n = n + (bytes[31] as u256) * 0x0000000000000000000000000000000000000000000000000000000000000001u256;

    from_u256(n)
}